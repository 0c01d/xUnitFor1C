Перем ТестовыеДанныхДляУдаления;

//{ основная процедура для юнит-тестирования xUnitFor1C
Перем юТест;

Функция ПолучитьСписокТестов(ЮнитТестирование) Экспорт
	
	юТест = ЮнитТестирование;
	
	ВсеТесты = Новый Массив;
	
	//юТест.ДобавитьПростыеТестыИзОбъекта(ВсеТесты, ЭтотОбъект);
			//ВсеТесты.Добавить("ТестДолжен_");
				
			//параметрыТеста = Новый Структура("ВерсияПлатформы,путь1С,Транзакция", "8.3.3.641", "C:\Program Files (x86)\1cv8\8.3.3.641\bin\1cv8.exe",Истина);
			//описаниеТеста = Новый Структура("ИмяТеста,Параметр", "ОТест_ОпределитьПравильныйПутьКПлатформеПоВерсииПлатформы", параметрыТеста);
			//ВсеТесты.Добавить(описаниеТеста);

	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияПростогоСправочника");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияОбъектаСЗаполненнымРеквизитомТипаПеречисление");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияДвухПростыхСправочников");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияДвухСвязанныхСправочников");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияСправочникаСРеквизитомСсылка_РежимПоискаКод");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияСправочникаСДвумяСтрокамиВТабличнойЧасти");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияДокументаСДвумяСтрокамиВТабличнойЧасти");

	Возврат ВсеТесты;
	
КонецФункции
//}

//{ ОСНОВНОЙ БЛОК
Функция МакетДляГенерацииДанных(МассивДанных) Экспорт
	ШапкаДанных = ШапкаДанныхВМакете();
	Макет = Новый  ТабличныйДокумент;	
	номерКолонки = 0;
	Для каждого ключЗначение Из ШапкаДанных Цикл
		номерКолонки = номерКолонки + 1;
		имяПоля = ключЗначение.Ключ;
		Макет.Область(1, номерКолонки, 1, номерКолонки).Текст = имяПоля ;
	КонецЦикла;
	Для каждого ОписательОбъекта Из МассивДанных Цикл
		ДобавитьОбъектВМакет(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных);
	КонецЦикла;
	Возврат Макет;
КонецФункции

Процедура ДобавитьОбъектВМакет(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных)
	Ссылка = ОписательОбъекта.Ссылка;
	Мд = Ссылка.Метаданные();
	
	ДобавитьМетаданныеВМакетДляДобавляемогоОбъекта(Макет, ОписательОбъекта, ШапкаДанных, Макет.ВысотаТаблицы+1, Мд);
	
	менеджерОбъекта = ПолучитьМенеджерОбъекта_Лкс(Мд);
	КорневойТипКонфигурации = ПолучитьКорневойТипКонфигурации_Лкс(Мд);
	Если КорневойТипКонфигурации = "Справочник" Тогда
		лПустойОбъект = менеджерОбъекта.СоздатьЭлемент();	
	ИначеЕсли КорневойТипКонфигурации = "Документ" Тогда
		лПустойОбъект = менеджерОбъекта.СоздатьДокумент();	
	Иначе
		ВызватьИсключение "Неизвестный КорневойТипКонфигурации <"+КорневойТипКонфигурации+">";
	КонецЕсли;
	
	объект = Ссылка.ПолучитьОбъект();
	
	ВыгружаемыеСтандартныеРеквизиты = ВыгружаемыеСтандартныеРеквизиты(ОписательОбъекта, КорневойТипКонфигурации);
	
	ОбработатьРеквизитыОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект, лПустойОбъект, Мд.СтандартныеРеквизиты, ВыгружаемыеСтандартныеРеквизиты);
	ОбработатьРеквизитыОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект, лПустойОбъект, Мд.Реквизиты, Неопределено);
	
	ОбработатьТабличныеЧастиОбъекта(Макет, Мд.ТабличныеЧасти, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект);
КонецПроцедуры

Процедура ДобавитьМетаданныеВМакетДляДобавляемогоОбъекта(Макет, ОписательОбъекта, ШапкаДанных, НомерСтрокиМакета, Мд)
	НомерКолонкиМакета = ШапкаДанных.Тип;
	ОбластьМакета = Макет.Область(НомерСтрокиМакета, номерКолонкиМакета, НомерСтрокиМакета, номерКолонкиМакета);
	ОбластьМакета.Текст = ПолучитьКорневойТипКонфигурации_Лкс(Мд);
	
	НомерКолонкиМакета = ШапкаДанных.Вид;
	ОбластьМакета = Макет.Область(НомерСтрокиМакета, номерКолонкиМакета, НомерСтрокиМакета, номерКолонкиМакета);
	ОбластьМакета.Текст = Мд.Имя;
	
	НомерКолонкиМакета = ШапкаДанных.ИмяПеременной;
	ОбластьМакета = Макет.Область(НомерСтрокиМакета, номерКолонкиМакета, НомерСтрокиМакета, номерКолонкиМакета);
	
	ИмяПеременной = ИмяПеременнойИзОписателяОбъекта(Мд, ОписательОбъекта);
	ОбластьМакета.Текст = ИмяПеременной;
КонецПроцедуры

Функция ВыгружаемыеСтандартныеРеквизиты(ОписательОбъекта, КорневойТипКонфигурации)
	ВыгружаемыеСтандартныеРеквизиты = Новый Массив;
	Если КорневойТипКонфигурации = "Справочник" Тогда
		ВыгружаемыеСтандартныеРеквизиты.Добавить("Наименование");
		ВыгружаемыеСтандартныеРеквизиты.Добавить("ПометкаУдаления");
		ВыгружатьКод = Ложь;
		Если ОписательОбъекта.Свойство("ВыгружатьКод", ВыгружатьКод) и ВыгружатьКод Тогда
			ВыгружаемыеСтандартныеРеквизиты.Добавить("Код");
		КонецЕсли;
	ИначеЕсли КорневойТипКонфигурации = "Документ" Тогда
		ВыгружаемыеСтандартныеРеквизиты.Добавить("Дата");
		ВыгружаемыеСтандартныеРеквизиты.Добавить("ПометкаУдаления");
		//ВыгружаемыеСтандартныеРеквизиты.Добавить("Проведен");
		ВыгружатьКод = Ложь;
		Если ОписательОбъекта.Свойство("ВыгружатьНомер", ВыгружатьКод) и ВыгружатьКод Тогда
			ВыгружаемыеСтандартныеРеквизиты.Добавить("Номер");
		КонецЕсли;
	Иначе
		ВызватьИсключение "Неизвестный КорневойТипКонфигурации <"+КорневойТипКонфигурации+"> КорневойТипКонфигурации()";
	КонецЕсли;
	
	Возврат ВыгружаемыеСтандартныеРеквизиты;
КонецФункции

Процедура ОбработатьРеквизитыОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект, лПустойОбъект, МдРеквизиты, ВыгружаемыеРеквизиты)
	НомерСтрокиМакета = Макет.ВысотаТаблицы+1;
	
	Мд = Объект.Метаданные();

	Для каждого РеквизитМд Из МдРеквизиты Цикл
		имяРеквизита = РеквизитМд.Имя;
		Если ВыгружаемыеРеквизиты <> Неопределено и ВыгружаемыеРеквизиты.Найти(имяРеквизита) = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		ЗначениеРеквизита = объект[имяРеквизита];

		этоЗначениеБудетСозданоПоУмолчанию = лПустойОбъект[имяРеквизита] = ЗначениеРеквизита;
		Если этоЗначениеБудетСозданоПоУмолчанию Тогда
			Продолжить;
		КонецЕсли;
		
		ОбработатьРеквизитОбъекта(Макет, Мд, МассивДанных, имяРеквизита, ЗначениеРеквизита, НомерСтрокиМакета, ШапкаДанных);
		
		НомерСтрокиМакета = НомерСтрокиМакета + 1;
	КонецЦикла;
КонецПроцедуры

Процедура ОбработатьТабличныеЧастиОбъекта(Макет, МдТабличныеЧасти, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект)
	Для каждого МдТч Из МдТабличныеЧасти Цикл
		МдРеквизиты = МдТч.Реквизиты;
		ИмяТЧ = МдТч.Имя;
		
		НомерКолонкиМакета = ШапкаДанных.ТЧ;
		
		Для каждого строкаТчОбъекта Из объект[ИмяТЧ] Цикл
			НомерСтрокиМакета = Макет.ВысотаТаблицы+1;
			ОбластьМакета = Макет.Область(НомерСтрокиМакета, номерКолонкиМакета, НомерСтрокиМакета, номерКолонкиМакета);
			ОбластьМакета.Текст = ИмяТЧ;
			
			ОбработатьРеквизитыТабличнойЧастиОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект, строкаТчОбъекта, МдРеквизиты);
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Процедура ОбработатьРеквизитыТабличнойЧастиОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект, строкаТчОбъекта, МдРеквизиты)
	НомерСтрокиМакета = Макет.ВысотаТаблицы+1;
	
	Мд = Объект.Метаданные();

	Для каждого РеквизитМд Из МдРеквизиты Цикл
		имяРеквизита = РеквизитМд.Имя;

		ЗначениеРеквизита = строкаТчОбъекта[имяРеквизита];

		ОбработатьРеквизитОбъекта(Макет, Мд, МассивДанных, имяРеквизита, ЗначениеРеквизита, НомерСтрокиМакета, ШапкаДанных);

		НомерСтрокиМакета = НомерСтрокиМакета + 1;
	КонецЦикла;
КонецПроцедуры

Процедура ОбработатьРеквизитОбъекта(Макет, Мд, МассивДанных, имяРеквизита, ЗначениеРеквизита, НомерСтрокиМакета, ШапкаДанных)
	НомерКолонкиМакета_Реквизит = ШапкаДанных.Реквизит;
	НомерКолонкиМакета_Значение = ШапкаДанных.Значение;
	НомерКолонкиМакета_Режим = ШапкаДанных.Режим;
	
	ОбластьМакета_Реквизит = Макет.Область(НомерСтрокиМакета, НомерКолонкиМакета_Реквизит, НомерСтрокиМакета, НомерКолонкиМакета_Реквизит);
	ОбластьМакета_Реквизит.Текст = имяРеквизита;
	
	ОбластьМакета_Значение = Макет.Область(НомерСтрокиМакета, НомерКолонкиМакета_Значение, НомерСтрокиМакета, НомерКолонкиМакета_Значение);
	ОбластьМакета_Режим = Макет.Область(НомерСтрокиМакета, НомерКолонкиМакета_Режим, НомерСтрокиМакета, НомерКолонкиМакета_Режим);
	
	типРеквизита = ТипЗнч(ЗначениеРеквизита);
	
	Если типРеквизита = Тип("Число") Тогда
		ОбластьМакета_Значение.Текст = Формат(ЗначениеРеквизита, "ЧГ=");
	ИначеЕсли типРеквизита = Тип("Строка") Тогда
		ОбластьМакета_Значение.Текст = ЗначениеРеквизита;
	ИначеЕсли типРеквизита = Тип("Дата") Тогда
		ОбластьМакета_Значение.Текст = Формат(ЗначениеРеквизита, "ДФ=yyyyMMdd");
	ИначеЕсли типРеквизита = Тип("Булево") Тогда
		ОбластьМакета_Значение.Текст = Формат(ЗначениеРеквизита, "БЛ=Ложь; БИ=Истина");			
		
	ИначеЕсли ЛиСсылкаНаОбъектБД_Лкс(ЗначениеРеквизита) Тогда
		ОписательЗначенияРеквизита = НайтиОписательОбъектаПоСсылке(МассивДанных, ЗначениеРеквизита); //МассивДанных.Найти(ЗначениеРеквизита);
		вычисленноеЗначениеРеквизита = "";
		Если ОписательЗначенияРеквизита <> Неопределено Тогда
			вычисленноеЗначениеРеквизита = ИмяПеременнойИзОписателяОбъекта(ЗначениеРеквизита.Метаданные(), ОписательЗначенияРеквизита);
			РежимПоиска = "Перем";
		Иначе
			вычисленноеЗначениеРеквизита = ЗначениеРеквизита;
			РежимПоиска = "Наименование";
		КонецЕсли;
		ОбластьМакета_Значение.Текст = вычисленноеЗначениеРеквизита;
		ОбластьМакета_Режим.Текст = РежимПоиска;
		
	ИначеЕсли ЛиСсылкаНаПеречисление_Лкс(ЗначениеРеквизита) Тогда
		ОбластьМакета_Значение.Текст = ЗначениеРеквизита;
		РежимПоиска = "Предопределенный";
		ОбластьМакета_Режим.Текст = РежимПоиска;
		
	Иначе
		ВызватьИсключение "Генератор макета из реальных данных: Не умею обрабатывать реквизит <"+имяРеквизита+"> у объекта <"+Мд.ПолноеИмя()+">";
	КонецЕсли;
КонецПроцедуры

Функция НайтиОписательОбъектаПоСсылке(МассивДанных, Ссылка)
	Для каждого ОписательОбъекта Из МассивДанных Цикл
		Если ОписательОбъекта.Ссылка = Ссылка Тогда
			Возврат ОписательОбъекта;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;
КонецФункции

Функция ИмяПеременнойИзОписателяОбъекта(Мд, ОписательОбъекта)
	ИмяПеременной = "";
	Если НЕ ОписательОбъекта.Свойство("ИмяПеременной", ИмяПеременной) или ПустаяСтрока(ИмяПеременной) Тогда
		ИмяПеременной = Мд.Имя;
	КонецЕсли;
	Возврат ИмяПеременной;
КонецФункции

Функция ШапкаДанныхВМакете()
	рез = Новый Структура();
	рез.Вставить("Тип", 1);
	рез.Вставить("Вид", 2);
	рез.Вставить("ИмяПеременной", 3);
	рез.Вставить("ТЧ", 4);
	рез.Вставить("Реквизит", 5);
	рез.Вставить("Значение", 6);
	рез.Вставить("Режим", 7);
	Возврат рез;						
КонецФункции

// { БЛОК МЕТОДОВ ИЗ ИР (Инструменты Разработчика, автор TormozIt )
//
// Определяет корневой тип конфигурации по описанию типов, типу, метаданным, ссылке или объекту.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем метаданные;
//  *пЛиТолькоДляКорневого - Булево, *Ложь - возвращать только для объекта корневого типа.
//
// Возвращаемое значение:
//               - Строка – имя типа корневого объекта метаданных;
//  Неопределено - не удалось получить имя типа.
//
Функция ПолучитьКорневойТипКонфигурации_Лкс(пОбъект, пЛиТолькоДляКорневого = Ложь) Экспорт

	Если ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда 
		МетаданныеТипа = пОбъект;
	Иначе
		МетаданныеТипа = ПолучитьМетаданные_Лкс(пОбъект);
	КонецЕсли;
	Результат = Неопределено;
	Если МетаданныеТипа <> Неопределено Тогда
		ПолноеИмя = МетаданныеТипа.ПолноеИмя();
		Если пЛиТолькоДляКорневого Тогда 
			МассивФрагментов = ПолучитьМассивИзСтрокиСРазделителем_Лкс(ПолноеИмя);
			Если МассивФрагментов.Количество() = 2 Тогда
				Результат = МассивФрагментов[0];
			КонецЕсли;
		Иначе
			Результат = ПолучитьПервыйФрагмент_Лкс(ПолноеИмя);
		КонецЕсли;
	КонецЕсли;
	Если Результат = "ТабличнаяЧасть" Тогда
		// Баг платформы. У внешних метаданных полное имя не включает сам внешний метаобъект
		Результат = Неопределено;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции // ЛксПолучитьКорневойТипКонфигурации()

// Проверяет, является ли значение ссылкой на объект БД. На базе ЛксЛиСсылкаНаОбъектБД
//
// Параметры:
//  пЗначение    – ОбъектМетаданных, Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Истина       – значение является ссылкой на объект БД;
//  Ложь         – значение не является ссылкой на объект БД.
//
Функция ЛиСсылкаНаОбъектБД_Лкс(пЗначение) Экспорт

	Возврат ЛиКорневойТипОбъектаБД_Лкс(ПолучитьКорневойТипКонфигурации_Лкс(пЗначение, Истина));
		
КонецФункции // ЛксЛиСсылкаНаОбъектБД

// Проверяет, является ли значение ссылкой на значение перечисления.
//
// Параметры:
//  пЗначение    – Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Истина       – значение является ссылкой на объект БД;
//  Ложь         – значение не является ссылкой на объект БД.
//
Функция ЛиСсылкаНаПеречисление_Лкс(пЗначение) Экспорт

	Возврат (ПолучитьКорневойТипКонфигурации_Лкс(пЗначение) = "Перечисление");

КонецФункции // ЛксЛиСсылкаНаПеречисление()

// Проверяет, является ли строка именем корневого типа объекта БД.
//
// Параметры:
//  пИмяКорневогоТипа - Строка, Неопределено - имя корневого типа.
//
// Возвращаемое значение:
//  Истина       – тип является корневым типом объекта БД;
//  Ложь         – иначе.
//
Функция ЛиКорневойТипОбъектаБД_Лкс(КорневойТип) Экспорт

	Если Ложь
		ИЛИ КорневойТип = "БизнесПроцесс" 
		ИЛИ КорневойТип = "Задача" 
		ИЛИ КорневойТип = "Документ"
		ИЛИ КорневойТип = "ПланВидовРасчета" 
		ИЛИ КорневойТип = "ПланВидовХарактеристик" 
		ИЛИ КорневойТип = "ПланОбмена"
		ИЛИ КорневойТип = "ПланСчетов" 
		ИЛИ КорневойТип = "Справочник"
	Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиКорневойТипОбъектаБД()

// Получает менеджер по описанию типов, типу, метаданным, ссылке или объекту. На базе метода ЛксПолучитьМенеджер
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем менеджер.
//
// Возвращаемое значение:
//               – МенеджерОбъекта - для ссылки или ссылочного типа;
//  Неопределено - не удалось получить.
//
Функция ПолучитьМенеджерОбъекта_Лкс(пОбъект) Экспорт
	
	Если ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда 
		МетаданныеОбъекта = пОбъект;
	Иначе
		МетаданныеОбъекта = ПолучитьМетаданные_Лкс(пОбъект);
	КонецЕсли;
	Если МетаданныеОбъекта = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	МассивФрагментов = ПолучитьМассивИзСтрокиСРазделителем_Лкс(МетаданныеОбъекта.ПолноеИмя());
	КорневойТип = МассивФрагментов[0];
	Менеджер = Неопределено;
	Если Истина
		И МассивФрагментов.Количество() = 4 
		И КорневойТип = "ВнешнийИсточникДанных" 
	Тогда
		ИмяТипаМенеджера = МассивФрагментов[0] + "ТаблицаМенеджер." + МассивФрагментов[1] + "." + МассивФрагментов[3];
	Иначе
		//КорневойТип = ЛксПолучитьКорневойТипКонфигурации(МетаданныеОбъекта, Истина); // Изменил 02.03.2012
		Если КорневойТип <> Неопределено Тогда
			ИмяТипаМенеджера = КорневойТип + "Менеджер." + МетаданныеОбъекта.Имя;
		Иначе
			ИмяТипаМенеджера = "Неопределено";
		КонецЕсли;
	КонецЕсли;
	Попытка
		Менеджер = Новый (ИмяТипаМенеджера);
	Исключение
	КонецПопытки;
	Возврат Менеджер;

КонецФункции // ЛксПолучитьМенеджер()

// Получает метаданные по полному имени, описанию типов, типу, ссылке или объекту. На базе ЛксПолучитьМетаданные
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем метаданные.
//
// Возвращаемое значение:
//               – Метаданные - полученные;
//  Неопределено - не удалось получить метаданные.
//
Функция ПолучитьМетаданные_Лкс(пОбъект) Экспорт
	
	Если ТипЗнч(пОбъект) = Тип("Строка") Тогда
		Если ПустаяСтрока(пОбъект) Тогда
			Результат = Неопределено;
		Иначе
			Фрагменты = ПолучитьМассивИзСтрокиСРазделителем_Лкс(пОбъект);
			Если Фрагменты.Количество() = 3 Тогда
				// ВидыСубконто, Изменения
				ПолноеИмяМД = Фрагменты[0] + "." + Фрагменты[1];
			Иначе
				ПолноеИмяМД = пОбъект;
			КонецЕсли; 
			Результат = Метаданные.НайтиПоПолномуИмени(ПолноеИмяМД);
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;
	ТипОбъекта = ПолучитьТипОбъекта_Лкс(пОбъект);
	Результат = Метаданные.НайтиПоТипу(ТипОбъекта);
	Возврат Результат;
	
КонецФункции // ЛксПолучитьМетаданные()

// Получает тип из описания типов, типа или значения. На базе ЛксПолучитьТипОбъекта
//
// Параметры:
//  пОбъект    – Тип, ОписаниеТипов, Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Тип - найденный тип.
//
Функция ПолучитьТипОбъекта_Лкс(пОбъект)

	ТипОбъекта = Тип("Неопределено");
	ТипПараметра = ТипЗнч(пОбъект);
	Если ТипПараметра = Тип("ОписаниеТипов") Тогда
		Если пОбъект.Типы().Количество() > 0 Тогда 
			ТипОбъекта = пОбъект.Типы()[0];
		КонецЕсли;
	ИначеЕсли ТипПараметра <> Тип("Тип") Тогда 
		ТипОбъекта = ТипПараметра;
	Иначе
		ТипОбъекта = пОбъект;
	КонецЕсли;
	
	Возврат ТипОбъекта;

КонецФункции // ЛксПолучитьТипОбъекта()

// Функция разбивает строку разделителем. На базе ЛксПолучитьМассивИзСтрокиСРазделителем
// 
// Параметры:
//  пСтрока      - Строка - которую разбиваем;
//  *пРазделитель - Строка, "." - символ-разделитель;
//  *ОбрезатьНепечатныеСимволы - Булево, *Ложь - делать СокрЛП.
//  *ОставлятьПустуюСтроку - Булево, *Истина - если передана пустая строка, то добавлять ее в массив.
//
// Возвращаемое значение:
//  Массив - фрагментов.
//
Функция ПолучитьМассивИзСтрокиСРазделителем_Лкс(Знач Стр, Разделитель = ".", ОбрезатьНепечатныеСимволы = Ложь, ОставлятьПустуюСтроку = Истина) Экспорт
	
	МассивСтрок = Новый Массив;
	Если Истина
		И Не ОставлятьПустуюСтроку 
		И ПустаяСтрока(Стр)
	Тогда
		Возврат МассивСтрок;
	КонецЕсли; 
	
	//лСтрока = СтрЗаменить(Стр, Разделитель, Символы.ПС);
	//// Баг платформы. СтрЧислоСтрок не учитывает терминальный перевод строки.
	//ЧислоСтрок = СтрЧислоСтрок(лСтрока + " ");
	//Для Счетчик = 1 По ЧислоСтрок Цикл 
	//	Фрагмент = СтрПолучитьСтроку(лСтрока, Счетчик);
	//	Если ОбрезатьНепечатныеСимволы Тогда
	//		Фрагмент = СокрЛП(Фрагмент);
	//	КонецЕсли;
	//	МассивСтрок.Добавить(Фрагмент);
	//КонецЦикла;
	
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				Фрагмент = Стр;
				Если ОбрезатьНепечатныеСимволы Тогда
					Фрагмент = СокрЛП(Фрагмент);
				КонецЕсли;
				МассивСтрок.Добавить(Фрагмент);
				Возврат МассивСтрок;
			КонецЕсли;
			Фрагмент = Лев(Стр,Поз-1);
			Если ОбрезатьНепечатныеСимволы Тогда
				Фрагмент = СокрЛП(Фрагмент);
			КонецЕсли;
			МассивСтрок.Добавить(Фрагмент);
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;

	Возврат МассивСтрок;
		
КонецФункции // ЛксПолучитьМассивИзСтрокиСРазделителем()

// Получает первый фрагмент, отделяемый разделителем от строки. На базе ЛксПолучитьПервыйФрагмент
// Написана для оптимизации по скорости.
// 
// Параметры:
//  пСтрока      - Строка - которую разбиваем;
//  *пРазделитель - Строка, "." - символ-разделитель;
//  *пЛиИспользоватьГраницуЕслиМаркерНеНайден - Булево, *Истина.
//
// Возвращаемое значение:
//               - Строка - первый фрагмент строки;
//  Неопределено - в строке не обнаружен разделитель.
//
Функция ПолучитьПервыйФрагмент_Лкс(пСтрока, пРазделитель = ".",
	пЛиИспользоватьГраницуЕслиМаркерНеНайден = Истина) Экспорт

	Позиция = Найти(пСтрока, пРазделитель);
	Если Позиция > 0 Тогда
		Возврат Лев(пСтрока, Позиция - 1);
	Иначе
		Если пЛиИспользоватьГраницуЕслиМаркерНеНайден Тогда 
			Возврат пСтрока;
		Иначе
			Возврат пСтрока;
		КонецЕсли;
	КонецЕсли;

КонецФункции // ЛксПолучитьПервыйФрагмент()

// } Конец блока методов из ИР (Инструменты Разработчика, автор TormozIt )

//} КОНЕЦ ОСНОВНОГО БЛОКА

//{ БЛОК ЮНИТ-ТЕСТОВ - сами тесты

Процедура ПередЗапускомТеста() Экспорт
	// в режиме транзакции какие-то проблемы с уникальностью кода :(
	// а вот без режима транзакций иногда не все созданные тестовые элементы Справочника.ПростойСправочник удаляются :(
	НачатьТранзакцию(); 
	
	ТестовыеДанныхДляУдаления = Новый Массив;
КонецПроцедуры

Процедура ПослеЗапускаТеста() Экспорт
	Если ТранзакцияАктивна() Тогда
		ОтменитьТранзакцию();
	КонецЕсли;	
	
	Для каждого ТестовыеДанные Из ТестовыеДанныхДляУдаления Цикл
		юТест.УдалитьСозданныеДанные(ТестовыеДанные);	
	КонецЦикла;
КонецПроцедуры

Процедура ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные)
	ТестовыеДанныхДляУдаления.Добавить(ТестовыеДанные);
КонецПроцедуры


Процедура ТестДолжен_ПолучитьМакетДляСозданияПростогоСправочника() Экспорт
	Макет = ПолучитьМакет("СозданиеПростогоСправочника");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
		
	Отбор = Новый Структура("Наименование,РеквизитБулево", "Тестовое наименование", Истина);
	
	КоличествоДо = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор);
		юТест.ПроверитьРавенство(1, количествоДо, "количествоДо");
		
	ИмяПеременной = "ПростойСправочник1"; // ИмяПеременной - необязательный элемент
	описаниеЭлемента = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, ИмяПеременной);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента);
		
	НовыйМакет = ЭтотОбъект.МакетДляГенерацииДанных(массивДанных);
	
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор), "количество после удаления");
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
	
		юТест.ПроверитьИстину(ТестовыеДанные.Свойство(ИмяПеременной), "Ожидали, что есть переменная '"+ИмяПеременной+"'");
		юТест.ПроверитьТип(ТестовыеДанные[ИмяПеременной], "СправочникСсылка.ПростойСправочник");
	
	КоличествоПосле = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор);
		юТест.ПроверитьРавенство(1, КоличествоПосле, "КоличествоПосле");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияОбъектаСЗаполненнымРеквизитомТипаПеречисление() Экспорт
	Макет = ПолучитьМакет("СозданиеОбъектаСЗаполненнымРеквизитомТипаПеречисление");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
	
	ЗначениеПеречисления = Перечисления.Перечисление1.ЗначениеПеречисления1;
	Отбор = Новый Структура("Наименование,РеквизитПеречисление", "тЗначениеПеречисления1", ЗначениеПеречисления);
	
	КоличествоДо = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор);
		юТест.ПроверитьРавенство(1, количествоДо, "количествоДо");
		
	ИмяПеременной = "ПростойСправочник1"; // ИмяПеременной - необязательный элемент
	описаниеЭлемента = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, ИмяПеременной);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента);
		
	НовыйМакет = ЭтотОбъект.МакетДляГенерацииДанных(массивДанных);
	
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор), "количество после удаления");
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
	
		юТест.ПроверитьРавенство(ТестовыеДанные[ИмяПеременной].РеквизитПеречисление, ЗначениеПеречисления, "СправочникСсылка.ПростойСправочник.РеквизитПеречисление");
	
	КоличествоПосле = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор);
		юТест.ПроверитьРавенство(1, КоличествоПосле, "КоличествоПосле");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияДвухПростыхСправочников() Экспорт
	Макет = ПолучитьМакет("СозданиеДвухПростыхСправочников");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
		
	Отбор = Новый Структура("Наименование", "Тестовое наименование", Истина);
	
	описаниеЭлемента = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, "ПростойСправочник1_1");
	описаниеЭлемента.Вставить("ВыгружатьКод", Ложь);

	ИмяПеременной2 = "ПростойСправочник2_1";
	описаниеЭлемента2 = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник2, ИмяПеременной2);
	описаниеЭлемента2.Вставить("ВыгружатьКод", Ложь);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента);
	МассивДанных.Добавить(описаниеЭлемента2);
		
	НовыйМакет = ЭтотОбъект.МакетДляГенерацииДанных(массивДанных);
	
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор), "количество после удаления");
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник2", Отбор), "количество2 после удаления");
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
		юТест.ПроверитьРавенство(2, ТестовыеДанные.Количество(), "ТестовыеДанные.Количество() НовыйМакет");
		юТест.ПроверитьИстину(ТестовыеДанные.Свойство(ИмяПеременной2), "Ожидали, что есть переменная '"+ИмяПеременной2+"'");
		юТест.ПроверитьТип(ТестовыеДанные[ИмяПеременной2], "СправочникСсылка.ПростойСправочник2");
	
	Количество2После = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник2", Отбор);
		юТест.ПроверитьРавенство(Количество2После, 1, "Количество2После");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияДвухСвязанныхСправочников() Экспорт
	Макет = ПолучитьМакет("СозданиеСвязанныхСправочников");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
		
	Отбор = Новый Структура("Наименование", "Тестовое наименование", Истина);
	
	ИмяПеременной = "ПростойСправочник1_1";
	описаниеЭлемента = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, ИмяПеременной);
	описаниеЭлемента.Вставить("ВыгружатьКод", Ложь);
	описаниеЭлемента.Вставить("РежимПоиска", "Наименование");

	ИмяПеременной2 = "ИерархическийСправочник_1";
	описаниеЭлемента2 = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ИерархическийСправочник, ИмяПеременной2);
	описаниеЭлемента2.Вставить("ВыгружатьКод", Ложь);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента);
	МассивДанных.Добавить(описаниеЭлемента2);
		
	НовыйМакет = ЭтотОбъект.МакетДляГенерацииДанных(массивДанных);
	
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор), "количество после удаления");
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ИерархическийСправочник", Отбор), "количество2 после удаления");
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
		юТест.ПроверитьРавенство(2, ТестовыеДанные.Количество(), "ТестовыеДанные.Количество() НовыйМакет");
	юТест.ПроверитьРавенство(ТестовыеДанные[ИмяПеременной], ТестовыеДанные[ИмяПеременной2].ПростойСправочник);
	
	Количество2После = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ИерархическийСправочник", Отбор);
		юТест.ПроверитьРавенство(Количество2После, 1, "Количество2После");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияСправочникаСРеквизитомСсылка_РежимПоискаКод() Экспорт
	Макет1 = ПолучитьМакет("СозданиеПростогоСправочника");
	ТестовыеДанные1 = юТест.СоздатьДанныеПоТабличномуДокументу(Макет1);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные1);
	
	Макет = ПолучитьМакет("СозданиеСправочникаСРеквизитомСсылка_РежимПоискаКод");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
		
	Отбор = Новый Структура("Наименование", "Тестовое наименование", Истина);
	
	ИмяПеременной2 = "ИерархическийСправочник_1";
	описаниеЭлемента2 = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ИерархическийСправочник, ИмяПеременной2);
	описаниеЭлемента2.Вставить("ВыгружатьКод", Ложь);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента2);
		
	НовыйМакет = ЭтотОбъект.МакетДляГенерацииДанных(массивДанных);
	
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ИерархическийСправочник", Отбор), "количество2 после удаления");
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
		юТест.ПроверитьРавенство(1, ТестовыеДанные.Количество(), "ТестовыеДанные.Количество() НовыйМакет");
	юТест.ПроверитьРавенство(ТестовыеДанные[ИмяПеременной2].ПростойСправочник.Наименование, "Тестовое наименование");
	
	Количество2После = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ИерархическийСправочник", Отбор);
		юТест.ПроверитьРавенство(Количество2После, 1, "Количество2После");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияСправочникаСДвумяСтрокамиВТабличнойЧасти() Экспорт
	Макет = ПолучитьМакет("СозданиеСправочникаСДвумяСтрокамиВТабличнойЧасти");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
	
	НаименованиеПростогоЭлемента = "Тест";
	Отбор = Новый Структура("Наименование", "Тестовое наименование", Истина);
	
	ИмяПеременной2 = "СправочникСТабЧастью";
	описаниеЭлемента2 = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.СправочникСТабЧастью, ИмяПеременной2);
	описаниеЭлемента2.Вставить("ВыгружатьКод", Ложь);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента2);
		
	НовыйМакет = ЭтотОбъект.МакетДляГенерацииДанных(массивДанных);
	
	тестовыеДанные.СправочникСТабЧастью.ПолучитьОбъект().Удалить();
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("СправочникСТабЧастью", Отбор), "количество2 после удаления");
		
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);	
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
		юТест.ПроверитьРавенство(1, ТестовыеДанные.Количество(), "ТестовыеДанные.Количество() НовыйМакет");
		юТест.ПроверитьРавенство(2, ТестовыеДанные[ИмяПеременной2].Состав.Количество(), "ТестовыеДанные[ИмяПеременной].Состав.Количество()");
	тч = ТестовыеДанные[ИмяПеременной2].Состав;
	строка0 = тч[0];
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента, строка0.ПростойСправочник.Наименование, "строка0.ПростойСправочник.Наименование");
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента+"1", строка0.ПростойСправочник2.Наименование, "строка0.ПростойСправочник2.Наименование");
		юТест.ПроверитьРавенство(Истина, строка0.РеквизитБулево, "строка0.РеквизитБулево");
	строка1 = тч[1];
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента, строка1.ПростойСправочник.Наименование, "строка1.ПростойСправочник.Наименование");
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента+"2", строка1.ПростойСправочник2.Наименование, "строка1.ПростойСправочник2.Наименование");
		юТест.ПроверитьРавенство(Ложь, строка1.РеквизитБулево, "строка1.РеквизитБулево");
	
	Количество2После = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("СправочникСТабЧастью", Отбор);
		юТест.ПроверитьРавенство(Количество2После, 1, "Количество2После");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияДокументаСДвумяСтрокамиВТабличнойЧасти() Экспорт
	Макет = ПолучитьМакет("СозданиеДокументаСДвумяСтрокамиВТабличнойЧасти");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
	
	НаименованиеПростогоЭлемента = "Тест";
	Отбор = Новый Структура; //("ПростойСправочник", ТестовыеДанные.ПростойСправочник);
	
	ИмяПеременной = "Документ2_2";
	описаниеЭлемента = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.Документ, ИмяПеременной);
	описаниеЭлемента.Вставить("ВыгружатьКод", Ложь);
	
	описаниеЭлемента_ПростойСправочник = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, "ПростойСправочник");
	описаниеЭлемента_ПростойСправочник.Вставить("ВыгружатьКод", Ложь);
	
	описаниеЭлемента_ПростойСправочник2 = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник22, "ПростойСправочник22");
	описаниеЭлемента_ПростойСправочник2.Вставить("ВыгружатьКод", Ложь);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента_ПростойСправочник);
	МассивДанных.Добавить(описаниеЭлемента_ПростойСправочник2);
	МассивДанных.Добавить(описаниеЭлемента);
		
	НовыйМакет = ЭтотОбъект.МакетДляГенерацииДанных(массивДанных);
	НовыйМакет.Показать();
	
	НачалоПериода = '20140401'; //НачалоДня(ТекущаяДата());
	ОкончаниеПериода = КонецДня(ТекущаяДата());
	тестовыеДанные.Документ.ПолучитьОбъект().Удалить();
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоДокументовПоОтбору("Документ1", НачалоПериода, ОкончаниеПериода, Отбор), "количество2 после удаления");
		
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);	
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);

		юТест.ПроверитьРавенство(3, ТестовыеДанные.Количество(), "ТестовыеДанные.Количество() НовыйМакет");
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента, ТестовыеДанные[ИмяПеременной].ПростойСправочник.Наименование, "ТестовыеДанные[ИмяПеременной].ПростойСправочник.Наименование");
		юТест.ПроверитьРавенство(2, ТестовыеДанные[ИмяПеременной].Состав.Количество(), "ТестовыеДанные[ИмяПеременной].Состав.Количество()");
	тч = ТестовыеДанные[ИмяПеременной].Состав;
	строка0 = тч[0];
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента+"1", строка0.ПростойСправочник2.Наименование, "строка0.ПростойСправочник2.Наименование");
		юТест.ПроверитьРавенство(Ложь, строка0.РеквизитБулево, "строка0.РеквизитБулево");
		юТест.ПроверитьРавенство(150, строка0.РеквизитЧисло, "строка0.РеквизитБулево");
	строка1 = тч[1];
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента+"2", строка1.ПростойСправочник2.Наименование, "строка1.ПростойСправочник2.Наименование");
		юТест.ПроверитьРавенство(Истина, строка1.РеквизитБулево, "строка1.РеквизитБулево");
		юТест.ПроверитьРавенство(0, строка1.РеквизитЧисло, "строка1.РеквизитБулево");
	
	Количество2После = юТест.ПолучитьКоличествоДокументовПоОтбору("Документ1", НачалоПериода, ОкончаниеПериода, Отбор);
		юТест.ПроверитьРавенство(1, Количество2После, "Количество2После");
КонецПроцедуры

//} КОНЕЦ БЛОКА ЮНИТ-ТЕСТОВ